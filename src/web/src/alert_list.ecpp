<#
 #
 # Copyright (C) 2015 - 2019 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 \file alert_list.ecpp
 \author Karol Hrdina <KarolHrdina@Eaton.com>
 \brief Retrieves a list of alerts known to the system according specified parameters
*/
#><%pre>
#include <exception>
#include <string>
#include <map>
#include <functional>
#include <tntdb/connection.h>
#include <tntdb/error.h>

#include <fty_proto.h>
#include "shared/utils_json.h"
#include <fty_common_rest_helpers.h>
#include <fty_common_db_dbpath.h>
#include <fty_common_db_asset.h>
#include <fty_common_mlm_utils.h>
#include <fty_common_mlm_tntmlm.h>
#include <fty_common_mlm_guards.h>
#include <fty_common_macros.h>
#include <fty_common_agents.h>
#include <fty_common_asset_types.h>

#define RFC_ALERTS_LIST "rfc-alerts-list"

static int
is_alertstate (const char *state) {
    if (!state)
        return 0;
    if (streq (state, "ACTIVE") ||
        streq (state, "ACK-WIP") ||
        streq (state, "ACK-IGNORE") ||
        streq (state, "ACK-PAUSE") ||
        streq (state, "ACK-SILENCE") ||
        streq (state, "RESOLVED")) {
        return 1;
    }
    return 0;
}

static int
is_requeststate (const char *state) {
    if (!state)
        return 0;
    if (streq (state, "ALL") ||
        streq (state, "ALL-ACTIVE")) {
        return 1;
    }
    return is_alertstate (state);
}

static zmsg_t*
s_request_list (zuuid_t *uuid, const std::string& filter, const std::vector<std::string>& desired_elements) {
    zmsg_t *send_msg = zmsg_new ();
    if (desired_elements.empty ()) {
        zmsg_addstr (send_msg, zuuid_str_canonical (uuid));
        zmsg_addstr (send_msg, "LISTALL");
        zmsg_addstr (send_msg, filter.c_str ());
    }
    else {
        zmsg_addstr (send_msg, zuuid_str_canonical (uuid));
        zmsg_addstr (send_msg, "LIST");
        zmsg_addstr (send_msg, filter.c_str ());
        for (auto const& item : desired_elements) {
            zmsg_addstr (send_msg, item.c_str ());
        }
    }

    return send_msg;
}

static std::string
s_response_list (zmsg_t *resp, tntdb::Connection& connection) {
    std::string json ( "[ ");

    std::string uuid = zmsg_popstr (resp);
    zframe_t *frame = zmsg_pop (resp);
    while (frame) {
        #if CZMQ_VERSION_MAJOR == 3
           zmsg_t *decoded_zmsg = zmsg_decode (zframe_data (frame), zframe_size (frame));
        #else
            zmsg_t *decoded_zmsg = zmsg_decode (frame);
        #endif
        zframe_destroy (&frame);

        if (!decoded_zmsg) {
           log_error ("Bad frame, skipping");
           frame = zmsg_pop (resp);
           continue;
        }
        fty_proto_t *decoded = fty_proto_decode (&decoded_zmsg);
        if (!decoded) {
           log_error ("Can't decode fty_proto");
           frame = zmsg_pop (resp);
           continue;
        }
        if (fty_proto_id (decoded) != FTY_PROTO_ALERT) {
           log_error ("message id is not FTY_PROTO_ALERT");
           fty_proto_destroy (&decoded);
           frame = zmsg_pop (resp);
           continue;
        }

        std::string jsonAlert = getJsonAlert(connection,decoded);

        if (jsonAlert.empty()){
           fty_proto_destroy (&decoded);
           frame = zmsg_pop (resp);
           continue;
        }
        frame = zmsg_pop (resp);
            if (frame)
                json += ", ";
    }

    json += " ]";

    return json;
}

</%pre>
<%request scope="global">
UserInfo user;
bool database_ready;
</%request>
<%cpp>
    // verify server is ready
    if (!database_ready) {
        log_debug ("Database is not ready yet.");
        std::string err =  TRANSLATE_ME ("Database is not ready yet, please try again after a while.");
        http_die ("internal-error", err.c_str ());
    }

    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Dashboard, "R"},
            {BiosProfile::Admin,     "R"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    // sanity checks
    std::string checked_state;
    std::string checked_asset;
    std::string checked_recursive;
    std::vector<std::string> desired_elements;
    {
        std::string state = qparam.param("state");
        std::string asset = qparam.param("asset");
        std::string recursive = qparam.param("recursive");
        log_debug ("Request parameters - Initial tainted values received:\n\tstate = '%s'\n\tasset = '%s'\n\trecursive = '%s'\n",
                state.c_str (), asset.c_str (), recursive.c_str ());

        // Check 'state' parameter
        if (state.empty ()) {
            state = "ALL-ACTIVE";
        }
        else
            if (!is_requeststate (state.c_str ())) {
                log_error ("state = '%s' is not a valid alert state.", state.c_str ());
                std::string msg1 = TRANSLATE_ME ("value '%s'", state.c_str ());
                std::string msg2 = TRANSLATE_ME ("one of the following values %s", "[ ALL | ALL-ACTIVE | ACTIVE | ACK-WIP | ACK-IGNORE | ACK-PAUSE | ACK-SILENCE | RESOLVED ]");
                http_die ("request-param-bad", "state", msg1.c_str(), msg2.c_str ());
            }

        // Check 'recursive' parameter
        if (recursive.empty ()) {
            recursive = "false";
        }
        else
            if (recursive.compare ("true") != 0 && recursive.compare ("false") != 0) {
                log_error ("recursive = '%s' is not a valid value.", recursive.c_str ());
                std::string msg1 = TRANSLATE_ME ("value '%s'", state.c_str ());
                std::string msg2 = TRANSLATE_ME ("one of the following values %s", "[true | false]");
                http_die ("request-param-bad", "recursive", msg1.c_str (), msg2.c_str ());
            }

        if (!asset.empty ())
        {
            if (!persist::is_ok_name (asset.c_str ()))
            {
                std::string msg  = TRANSLATE_ME ("valid asset name");
                http_die ("request-param-bad", "asset", asset.c_str (), msg.c_str ());
            }
        }

        checked_state = state;
        checked_asset = asset;
        checked_recursive = recursive;

        log_debug ("Request parameters - un-tainted values applied:\n"
                "\tstate = '%s'\n\tasset = '%s'\n\trecursive = '%s'\n",
                state.c_str (), asset.c_str (), recursive.c_str ());
    }

    tntdb::Connection connection;
    try {
        connection = tntdb::connectCached (DBConn::url);
    }
    catch (const tntdb::Error& e) {
        std::string err = JSONIFY (e.what ());
        http_die ("internal-error", err.c_str ());
    }
    catch (const std::exception& e) {
        std::string err =  JSONIFY (e.what ());
        http_die ("internal-error", err.c_str ());
    }

    if (!checked_asset.empty ()) {
        int64_t element_id = DBAssets::name_to_asset_id (checked_asset);
        if (element_id == -1)
            http_die ("element-not-found", checked_asset.c_str ());
        if (element_id == -2) {
            std::string err =  TRANSLATE_ME ("Connecting to database failed.");
            http_die ("internal-error", err.c_str ());
        }
        log_debug ("Asset element id = '%" PRIu32 "'.", element_id);

        desired_elements = {checked_asset};
        if (checked_recursive == "true") {
            try {
                int rv = DBAssets::select_assets_by_container (
                        connection,
                        element_id,
                        [&desired_elements](const tntdb::Row& row) -> void {
                            std::string name;
                            row[0].get (name);
                            desired_elements.push_back (name);
                        });
                if (rv != 0) {
                    std::string err =  TRANSLATE_ME ("DBAssets::select_assets_by_container () failed.");
                    http_die ("internal-error", err.c_str ());
                }
            }
            catch (const tntdb::Error& e) {
                std::string err = JSONIFY (e.what ());
                http_die ("internal-error", err.c_str ());
            }
            catch (const std::exception& e) {
                std::string err =  JSONIFY (e.what ());
                http_die ("internal-error", err.c_str ());
            }

            log_trace ("=== These elements are topologically under element id: '%" PRIu32"' ===", element_id);
            for (auto const& item : desired_elements) {
                log_trace ("%s", item.c_str ());
            }
            log_trace ("=== end ===");
        }
    }

    MlmClientPool::Ptr client = mlm_pool.get ();
    if (!client.getPointer ())
    {
        std::string err = TRANSLATE_ME ("mlm_pool.get () failed.");
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    zuuid_t *uuid = zuuid_new ();
    zmsg_t *request_msg = s_request_list (uuid, checked_state, desired_elements);
    int rv = client->sendto (AGENT_FTY_ALERT_LIST, RFC_ALERTS_LIST, 1000, &request_msg);

    if (rv == -1)
    {
        zuuid_destroy (&uuid);
        std::string err = TRANSLATE_ME ("client->sendto (address = '%s') failed.", AGENT_FTY_ALERT_LIST);
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    ZmsgGuard resp (client->recv (zuuid_str_canonical (uuid), 5));
    zuuid_destroy (&uuid);
    if (!resp)
    {
        std::string err = TRANSLATE_ME ("client->recv (timeout = '5') returned NULL");
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    if (!streq (client->subject (), RFC_ALERTS_LIST)) {
        log_error ("Unexpected reply from '%s'. Subject expected = '%s', received = '%s'.",
            client->sender (), RFC_ALERTS_LIST, client->subject ());
        std::string err =  TRANSLATE_ME ("Bad message.");
        http_die ("internal-error", err.c_str ());
    }

    std::string json;
    ZstrGuard part (zmsg_popstr (resp));
    if (streq (part, "LISTALL")) {
        part = zmsg_popstr (resp);
        //part = zmsg_popstr (resp);
        json = s_response_list (resp, connection);
        if (json.empty ()) {
            std::string err = TRANSLATE_ME ("Invalid reply from %s", AGENT_FTY_ALERT_LIST);
            http_die ("internal-error", err.c_str ());
        }
    }
    else if (streq (part, "LIST")) {
        part = zmsg_popstr (resp);
        //part = zmsg_popstr (resp);
        json = s_response_list (resp, connection);
        if (json.empty ()) {
            std::string err = TRANSLATE_ME ("Invalid reply from %s", AGENT_FTY_ALERT_LIST);
            http_die ("internal-error", err.c_str ());
        }
    }
    else {
        part = zmsg_popstr (resp);
        if (!part) {
            log_error ("Unexpected reply from '%s'. Expected ERROR/reason. Got ERROR/(null).", AGENT_FTY_ALERT_LIST);
            std::string err =  TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
        else {
            std::string reason = part.get();
            std::string err =  TRANSLATE_ME ("Error while requesting list of alerts: %s", reason.c_str ());
            http_die ("internal-error", err.c_str ());
        }
   }
</%cpp>
<$$ json $>
