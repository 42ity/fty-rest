<#
 #
 # Copyright (C) 2015 - 2019 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 \file alert_ack.ecpp
 \author Karol Hrdina <KarolHrdina@Eaton.com>
 \brief Implementation of REST API call for PUT alerts/ack/<rule_name>/<element_name>
*/
#><%pre>
#include <exception>
#include <cxxtools/jsondeserializer.h>
#include <string>

#include <fty_common_rest_helpers.h>
#include <fty_common_mlm_tntmlm.h>
#include <fty_common_mlm_guards.h>
#include <fty_common.h>
#include <fty_common_macros.h>
#include <fty_common_db_asset.h>

#define RFC_ALERTS_ACK "rfc-alerts-acknowledge"

static
int state_valid (const char *state) {
    assert (state);
    if (streq (state, "ACTIVE") ||
        streq (state, "ACK-WIP") ||
        streq (state, "ACK-IGNORE") ||
        streq (state, "ACK-PAUSE") ||
        streq (state, "ACK-SILENCE"))
        return 1;
    return 0;
}

static zmsg_t*
s_request_ack (zuuid_t *uuid, const std::string& rule_name, const std::string& element_name, const std::string& state) {
    zmsg_t *send_msg = zmsg_new ();
    zmsg_addstr (send_msg, "CHANGESTATE");
    zmsg_addstr (send_msg, zuuid_str_canonical (uuid));
    std::string alert_id (rule_name + "@" + element_name);
    zmsg_addstr (send_msg, alert_id.c_str ());
    zmsg_addstr (send_msg, state.c_str ());

    return send_msg;
}

</%pre>
<%request scope="global">
UserInfo user;
bool database_ready;
</%request>
<%cpp>
    // verify server is ready
    if (!database_ready) {
        log_debug ("Database is not ready yet.");
        std::string err = TRANSLATE_ME ("Database is not ready yet, please try again after a while.");
        http_die ("internal-error", err.c_str ());
    }

    // permission check
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Admin,     "RU"}
            };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    // checked input arguments
    std::string checked_rule_name;
    std::string checked_element_name; // after last change this is unicode name
    std::string checked_state;

    // ##################################################
    // BLOCK 1
    // Sanity parameter check
    {
        // validate method
        if (request.getMethod () != "PUT") {
            http_die ("method-not-allowed", request.getMethod ().c_str ());
        }

        // validate input params
        std::string rule_name = request.getArg ("rule_name");
        std::string element_name = request.getArg ("element_name");
        log_debug ("Request parameters - Initial tainted values received:\n\trule_name = '%s'\n\telement_name = '%s'\n",
                    rule_name.c_str (), element_name.c_str ());

        http_errors_t errors;
        if (! check_asset_name ("element_name", element_name, errors)) {
            http_die_error (errors);
        }
        checked_element_name = element_name;

        if (! check_alert_rule_name ("rule_name", rule_name, errors)) {
            http_die_error (errors);
        }
        checked_rule_name = rule_name;

        // validate request document
        std::string state;
        cxxtools::SerializationInfo si;
        try {
            std::stringstream input (request.getBody (), std::ios_base::in);
            cxxtools::JsonDeserializer deserializer (input);
            deserializer.deserialize (si);
            si.getMember ("state") >>= state;
            if (state.empty ())
                throw std::runtime_error (TRANSLATE_ME ("property 'state' has empty value"));
        }
        catch (const std::exception& e) {
            log_debug ("Bad request document - invalid json: %s", e.what ());
            std::string err = TRANSLATE_ME ("Expected format: { \"state\" : <state> }");
            http_die ("bad-request-document", err.c_str ());
        }
        log_debug ("state = '%s'", state.c_str ());

        if (!state_valid (state.c_str ())) {
            log_debug ("State is not a recognized valid alert state.");
            std::string err = TRANSLATE_ME ("one of the following values [ ACTIVE | ACK-WIP | ACK-IGNORE | ACK-PAUSE | ACK-SILENCE ].");
            http_die ("request-param-bad", "state", state.c_str (), err.c_str ());
        }
        else {
            checked_state = state;
        }
    }

    // convert external name to asset ID
    std::string asset_id;
    int rv = DBAssets::extname_to_asset_name (checked_element_name, asset_id);
    if (rv == -1) {
        std::string msg_not_found = TRANSLATE_ME ("Cannot get asset ID for %s", checked_element_name.c_str ());
        http_die ("not-found", msg_not_found.c_str ());
    }
    if (rv == -2) {
        std::string err =  TRANSLATE_ME ("Database failure");
        http_die ("internal-error", err.c_str ());
    }

    MlmClientPool::Ptr client = mlm_pool.get ();
    if (!client.getPointer ())
    {
        std::string err = TRANSLATE_ME ("mlm_pool.get () failed.");
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    zuuid_t *uuid = zuuid_new ();
    zmsg_t *request_msg = s_request_ack (uuid, checked_rule_name, checked_element_name, checked_state);
    rv = client->sendto (AGENT_FTY_ALERT_LIST, RFC_ALERTS_ACK, 1000, &request_msg);

    if (rv == -1)
    {
        zuuid_destroy (&uuid);
        std::string err = TRANSLATE_ME ("client->sendto (address = '%s') failed.", AGENT_FTY_ALERT_LIST);
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    ZmsgGuard resp (client->recv (zuuid_str_canonical (uuid), 5));
    zuuid_destroy (&uuid);
    if (!resp)
    {
        std::string err = TRANSLATE_ME ("client->recv (timeout = '5') returned NULL");
        log_fatal (err.c_str ());
        http_die ("internal-error", err.c_str ());
    }

    if (!streq (client->subject (), RFC_ALERTS_ACK)) {
        log_error ("Unexpected reply from '%s'. Subject expected = '%s', received = '%s'.",
            client->sender (), RFC_ALERTS_ACK, client->subject ());
        std::string err =  TRANSLATE_ME ("Bad message.");
        http_die ("internal-error", err.c_str ());
    }

    std::string json;
    ZstrGuard part (zmsg_popstr (resp));
    if (streq (part, "CHANGESTATE")) {
        part = zmsg_popstr (resp);
        if (!part || !streq (part, zuuid_str_canonical (uuid))) {
            log_error ("Unexpected reply from '%s': Wrong correlation ID", client->sender ());
            std::string err =  TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
        part = zmsg_popstr (resp);
        std::string alert_id (checked_rule_name + "@" + checked_element_name);
        if (!part || !streq (part, alert_id.c_str ())) {
            log_error ("Unexpected reply from '%s': Incorrect alert ID", client->sender ());
            std::string err =  TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
    // TODO: rfc-11 is not written yet, json format can change freely
    </%cpp>
    {
        <$$ utils::json::jsonify ("rule_name", checked_rule_name) $>,
        <$$ utils::json::jsonify ("asset_id", asset_id) $>,
        <$$ utils::json::jsonify ("element_name", checked_element_name) $>,
        <$$ utils::json::jsonify ("state", checked_state) $>
    }
    <%cpp>
        return HTTP_OK;
    }
    else if (streq (part, "ERROR")) {
        part = zmsg_popstr (resp);
        if (!part) {
            log_error ("Unexpected reply from '%s'. Expected ERROR/reason. Got ERROR/(null).", client->sender ());
            std::string err =  TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
        if (streq (part, "NOT_FOUND")) {
            log_error ("Alert identified by rule_name = '%s' and element_name = '%s' does not exist.",
                checked_rule_name.c_str (), asset_id.c_str ());
            std::string msg_not_found = TRANSLATE_ME ("Alert identified by rule name = '%s' and element name = '%s'", checked_rule_name.c_str (), checked_element_name.c_str ());
            http_die ("not-found", msg_not_found.c_str ());
        }
        if (streq (part, "BAD_STATE")) {
            log_error ("Alert identified by rule_name = '%s' and element_name = '%s' can not change state to '%s'.",
                checked_rule_name.c_str (), checked_element_name.c_str (), checked_state.c_str ());
            std::string msg_param_conflict = TRANSLATE_ME ("Alert identified by rule name = '%s', element name = '%s' can not change state to '%s'.", checked_rule_name.c_str (), checked_element_name.c_str (), checked_state.c_str ());
            http_die ("parameter-conflict", msg_param_conflict.c_str ());
        }
        if (streq (part, "BAD_COMMAND")) {
            std::string err = TRANSLATE_ME ("Unexpected command");
            log_error (err.c_str ());
            http_die ("internal-error", err.c_str ());
        }
        else {
            std::string reason = part.get();
            std::string msg_unspecified = TRANSLATE_ME ("Error while setting state of alert identified by rule name = '%s', element = '%s' to '%s'", checked_rule_name.c_str (), checked_element_name.c_str (), checked_state.c_str ());
            http_die ("internal-error", msg_unspecified.c_str ());
        }
    }
    else {
        // Message does not conform to protocol
        log_error ("Unexptected reply from  '%s'. Does not conform to rfc-evaluator-rules.", client->sender ());
        std::string err =  TRANSLATE_ME ("Bad message.");
        http_die ("internal-error", err.c_str ());
    }
</%cpp>
