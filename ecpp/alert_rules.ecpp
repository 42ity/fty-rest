<#
 #
 # Copyright (C) 2015 - 2020 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 \file alert_rules.ecpp
 \author Karol Hrdina <KarolHrdina@Eaton.com>
 \brief  Create or updates specified alert rule
*/
#><%pre>
#include <fty_common_rest_helpers.h>
#include <fty_common_mlm_utils.h>
#include <fty_common_mlm_guards.h>
#include <fty_common_rest_audit_log.h>
#include <cxxtools/regex.h>
#include <string>
#include <malamute.h>
</%pre>
<%request scope="global">
UserInfo user;
</%request>
<%cpp>
    // allow POST|PUT only
    if (request.getMethod () != "POST" && request.getMethod () != "PUT") {
        http_die ("method-not-allowed", request.getMethod ().c_str ());
    }

    // check user permissions
    {
        static const std::map <BiosProfile, std::string> PERMISSIONS = {
            {BiosProfile::Admin, "CU"}
        };
        std::string audit_msg = "Request CREATE alert rule FAILED";
        if (request.getMethod () == "PUT") {
            audit_msg = "Request CREATE OR UPDATE alert rule FAILED";
        }
        CHECK_USER_PERMISSIONS_OR_DIE_AUDIT (PERMISSIONS, audit_msg.c_str ());
    }

    // sanity check
    std::string checked_name;
    {
        std::string name = request.getArg ("name");

        if (request.getMethod () == "PUT") {
            http_errors_t errors;
            if (! check_alert_rule_name ("name", name, errors)) {
                http_die_error (errors);
            }
        }

        if (request.getMethod () == "PUT" && name.empty()) {
            std::string received = TRANSLATE_ME ("empty value");
            std::string expected = TRANSLATE_ME ("non-empty value");
            http_die ("request-param-bad", "name", received.c_str (), expected.c_str ());
        }

        if (request.getMethod () == "POST" && !name.empty ()) {
            std::string received = TRANSLATE_ME ("non-empty value");
            std::string expected = TRANSLATE_ME ("empty value");
            http_die ("request-param-bad", "name", received.c_str (), expected.c_str ());
        }

        checked_name = name;
    }

    log_debug ("requested rule name = '%s'.", checked_name.c_str ());

    #define LOG_ERROR_AUDIT \
        log_error_audit ("Request %s alert rule named %s FAILED", \
            (request.getMethod () == "POST" ? "CREATE" : "CREATE OR UPDATE"), checked_name.c_str ())
    #define LOG_INFO_AUDIT \
        log_info_audit ("Request %s alert rule named %s SUCCESS", \
            (request.getMethod () == "POST" ? "CREATE" : "CREATE OR UPDATE"), checked_name.c_str ())

    // connect to malamute
    MlmClientGuard client (mlm_client_new ());
    {
        if (!client) {
            LOG_ERROR_AUDIT;
            log_fatal ("mlm_client_new () failed.");
            std::string err = TRANSLATE_ME ("mlm_client_new () failed.");
            http_die ("internal-error", err.c_str ());
        }

        std::string client_name = utils::generate_mlm_client_id ("web.alert_rules");
        log_debug ("malamute client name = '%s'.", client_name.c_str ());

        uint32_t connect_timeout = 1000; // ms
        int rv = mlm_client_connect (client, MLM_ENDPOINT, connect_timeout, client_name.c_str ());
        if (rv == -1) { // if failed, retry with larger timeout
            connect_timeout += 1000;
            rv = mlm_client_connect (client, MLM_ENDPOINT, connect_timeout, client_name.c_str ());
        }
        if (rv == -1) {
            LOG_ERROR_AUDIT;
            log_fatal ("mlm_client_connect (endpoint = '%s', timeout = '%d', address = '%s') failed.",
                            MLM_ENDPOINT, connect_timeout, client_name.c_str ());
            std::string err = TRANSLATE_ME ("mlm_client_connect () failed.");
            http_die ("internal-error", err.c_str ());
        }
    }

    const char* DESTINATION = "fty-alert-engine";
    // is it flexible?
    {
        cxxtools::Regex reg ("^[[:blank:][:cntrl:]]*\\{[[:blank:][:cntrl:]]*\"flexible\"", REG_EXTENDED);
        if (reg.match (request.getBody ())) {
            DESTINATION = "fty-alert-flexible";
        }
    }

    const char* RULES_SUBJECT = "rfc-evaluator-rules";
    const char* COMMAND = "ADD";

    // Send message
    {
        zmsg_t *send_msg = zmsg_new ();
        if (!send_msg) {
            LOG_ERROR_AUDIT;
            log_fatal ("zmsg_new () failed.");
            std::string err = TRANSLATE_ME ("zmsg_new () failed.");
            http_die ("internal-error", err.c_str ());
        }
        zmsg_addstr (send_msg, COMMAND);
        zmsg_addstr (send_msg, request.getBody ().c_str ());
        if (request.getMethod () == "PUT") {
            zmsg_addstr (send_msg, checked_name.c_str ());
        }

        // send it
        int rv = mlm_client_sendto (client, DESTINATION, RULES_SUBJECT, NULL, 1000, &send_msg);
        zmsg_destroy (&send_msg);
        if (rv != 0) {
            LOG_ERROR_AUDIT;
            log_debug ("mlm_client_sendto (address = '%s', subject = '%s', tracker = NULL, timeout = '%d') failed.",
                DESTINATION, RULES_SUBJECT, 1000);
            std::string err = TRANSLATE_ME ("mlm_client_sendto () failed.");
            http_die ("internal-error", err.c_str ());
        }
    }

    // Get response
    ZmsgGuard recv_msg;
    {
        ZpollerGuard poller (zpoller_new (mlm_client_msgpipe (client), NULL));
        if (!poller) {
            LOG_ERROR_AUDIT;
            log_fatal ("zpoller_new () failed.");
            std::string err = TRANSLATE_ME ("zpoller_new () failed.");
            http_die ("internal-error", err.c_str ());
        }

        while (true) {
            void* which = zpoller_wait (poller, 5000);
            if (which) {
                recv_msg = mlm_client_recv (client);
            }
            if (!recv_msg) {
                LOG_ERROR_AUDIT;
                if (zpoller_expired (poller) || zpoller_terminated (poller)) {
                    log_error ("zpoller_wait (timeout = 5000) timed out waiting for message.");
                    std::string err = TRANSLATE_ME ("Timed out waiting for message.");
                    http_die ("internal-error", err.c_str ());
                }
                log_error ("mlm_client_recv () failed.");
                std::string err = TRANSLATE_ME ("mlm_client_recv () failed.");
                http_die ("internal-error", err.c_str ());
            }
            if (streq (mlm_client_sender (client), DESTINATION))
                break;
        }

        // Got it. Check subject
        if (!streq (mlm_client_subject (client), RULES_SUBJECT)) {
            LOG_ERROR_AUDIT;
            log_error ("Unexpected reply from '%s'. Subject expected = '%s', received = '%s'.",
                mlm_client_sender (client), "rfc-evaluator-rules", mlm_client_subject (client));
            std::string err = TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
    }

    // Check response
    // OK/rule
    // ERROR/reason

    ZstrGuard part (zmsg_popstr (recv_msg));

    if (streq (part, "OK")) {
        part = zmsg_popstr (recv_msg); // rule
        if (!part) {
            LOG_ERROR_AUDIT;
            log_error ("Unexpected reply from '%s'. Expected OK/json. Got OK/(null).", mlm_client_sender (client));
            std::string err = TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
        // Assume part is a valid json
        reply.out() << part.get();
        LOG_INFO_AUDIT;
    }
    else if (streq (part, "ERROR")) {

        LOG_ERROR_AUDIT;

        part = zmsg_popstr (recv_msg); // reason

        if (!part) {
            log_error ("Unexpected reply from '%s'. Expected ERROR/reason. Got ERROR/(null).", mlm_client_sender (client));
            std::string err = TRANSLATE_ME ("Bad message.");
            http_die ("internal-error", err.c_str ());
        }
        if (streq (part, "NOT_FOUND")) {
            log_error ("Rule name '%s' does not exist.", checked_name.c_str ());
            std::string err = TRANSLATE_ME ("Rule name '%s'", checked_name.c_str ());
            http_die ("not-found", err.c_str ());
        }
        if (streq (part, "BAD_LUA")) {
            log_error ("Request document has lua syntax error.");
            std::string err = TRANSLATE_ME ("Request document has lua syntax error.");
            http_die ("bad-request-document", err.c_str ());
        }
        if (streq (part, "BAD_JSON") || streq (part, "RULE_HAS_ERRORS")) {
            log_error ("Request document not valid json or does not adhere to specified schema.");
            std::string err = TRANSLATE_ME ("Please check RFC-11 for valid rule json schema description.");
            http_die ("bad-request-document", err.c_str ());
        }
        if (streq (part, "ALREADY_EXISTS")) {
            log_error ("Requested document already exists.");
            std::string err = TRANSLATE_ME ("Rule with such name (new rule name) already exists");
            http_die ("parameter-conflict", err.c_str ());
        }

        log_error ("%s/%s request failed (reason: %s)", mlm_client_sender (client), COMMAND, part.get());
        std::string err = TRANSLATE_ME ("Error while retrieving details of rule name = '%s': %s.",
            checked_name.c_str (), part.get());
        http_die ("internal-error", err.c_str ());
    }
    else {
        LOG_ERROR_AUDIT;
        // Message does not conform to protocol
        log_error ("Unexpected reply from '%s'. Does not conform to %s.", mlm_client_sender (client), RULES_SUBJECT);
        std::string err = TRANSLATE_ME ("Bad message.");
        http_die ("internal-error", err.c_str ());
    }

    #undef LOG_ERROR_AUDIT
    #undef LOG_INFO_AUDIT
</%cpp>
