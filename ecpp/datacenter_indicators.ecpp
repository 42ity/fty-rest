<#
 #
 # Copyright (C) 2015 - 2020 Eaton
 #
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 #
 # You should have received a copy of the GNU General Public License along
 # with this program; if not, write to the Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 #
 #><#
/*!
 * \file datacenter_indicators.ecpp
 * \author Tomas Halman <TomasHalman@Eaton.com>
 * \author Alena Chernikava <AlenaChernikava@Eaton.com>
 * \author Karol Hrdina <KarolHrdina@Eaton.com>
 * \author Michal Vyskocil <MichalVyskocil@Eaton.com>
 * \brief  returns Current values of some metrics for datacenters
 */
 #><%pre>
#include "shared/data.h"
#include "shared/utilspp.h"

#include <fty_shm.h>
#include <fty_proto.h>
#include <fty_log.h>
#include <fty_common_rest_helpers.h>
#include <cxxtools/split.h>

//
// ATTENTION
// trend_ (sep '/'):first one should be average, second one is raw measurement
//
static const std::map<std::string, const std::string> PARAM_TO_SRC
{
    {"power", "realpower.default"},

    {"avg_power_last_day", "realpower.default_arithmetic_mean_24h"},
    {"avg_power_last_week", "realpower.default_arithmetic_mean_7d"},
    {"avg_power_last_month", "realpower.default_arithmetic_mean_30d"},

    {"min_power_last_day", "realpower.default_min_24h"},
    {"min_power_last_week", "realpower.default_min_7d"},
    {"min_power_last_month", "realpower.default_min_30d"},

    {"max_power_last_day", "realpower.default_max_24h"},
    {"max_power_last_week", "realpower.default_max_7d"},
    {"max_power_last_month", "realpower.default_max_30d"},

    {"trend_power_last_day", "realpower.default_arithmetic_mean_24h/realpower.default"},
    {"trend_power_last_week", "realpower.default_arithmetic_mean_7d/realpower.default"},
    {"trend_power_last_month", "realpower.default_arithmetic_mean_30d/realpower.default"},

    {"consumption_last_day", "realpower.default_consumption_24h"},
    {"consumption_last_week", "realpower.default_consumption_7d"},
    {"consumption_last_month", "realpower.default_consumption_30d"},

    {"temperature", "average.temperature"},

    {"avg_temperature_last_day",  "average.temperature_arithmetic_mean_24h"},
    {"avg_temperature_last_week", "average.temperature_arithmetic_mean_7d"},
    {"avg_temperature_last_month", "average.temperature_arithmetic_mean_30d"},

    {"min_temperature_last_day",  "average.temperature_min_24h"},
    {"min_temperature_last_week", "average.temperature_min_7d"},
    {"min_temperature_last_month", "average.temperature_min_30d"},

    {"max_temperature_last_day",  "average.temperature_max_24h"},
    {"max_temperature_last_week", "average.temperature_max_7d"},
    {"max_temperature_last_month", "average.temperature_max_30d"},

    {"trend_temperature_last_day",  "average.temperature_arithmetic_mean_24h/average.temperature"},
    {"trend_temperature_last_week", "average.temperature_arithmetic_mean_7d/average.temperature"},
    {"trend_temperature_last_month", "average.temperature_arithmetic_mean_30d/average.temperature"},

    {"humidity", "average.humidity"},

    {"avg_humidity_last_day", "average.humidity_arithmetic_mean_24h"},
    {"avg_humidity_last_week", "average.humidity_arithmetic_mean_7d"},
    {"avg_humidity_last_month", "average.humidity_arithmetic_mean_30d"},

    {"min_humidity_last_day", "average.humidity_min_24h"},
    {"min_humidity_last_week", "average.humidity_min_7d"},
    {"min_humidity_last_month", "average.humidity_min_30d"},

    {"max_humidity_last_day", "average.humidity_max_24h"},
    {"max_humidity_last_week", "average.humidity_max_7d"},
    {"max_humidity_last_month", "average.humidity_max_30d"},

    {"trend_humidity_last_day", "average.humidity_arithmetic_mean_24h/average.humidity"},
    {"trend_humidity_last_week", "average.humidity_arithmetic_mean_7d/average.humidity"},
    {"trend_humidity_last_month", "average.humidity_arithmetic_mean_30d/average.humidity"},
};

static bool s_is_valid_param(const std::string& p)
{
    return PARAM_TO_SRC.count(p) != 0;
}

static bool is_trend(const std::string &p)
{
    return p.find("trend_") == 0; // 'trend_' prefix
}

static double s_compute_trend_value (
    const std::string &p, // trend param
    const std::map<std::string, std::string> &metrics // <name, value>
)
{
    double value = NAN; // default

    do {
        std::vector<std::string> items;
        cxxtools::split('/', PARAM_TO_SRC.at(p), std::back_inserter(items));
        if (items.size() != 2) {
            break;
        }

        auto it0 = metrics.find(items.at(0));
        auto it1 = metrics.find(items.at(1));
        if ((it0 == metrics.cend()) || (it1 == metrics.cend())) {
            break;
        }

        double average = std::stod(it0->second);
        double current = std::stod(it1->second);
        if (average == 0.0) {
            break;
        }

        // trend (%)
        value = ((current - average) / average) * 100.0;
        // trunc to two decimals
        value = round(value * 100) / 100;
        break;
    } while(0);

    return value;
}
</%pre>
<%thread scope="global">
asset_manager asset_mgr;
</%thread>
<%request scope="global">
UserInfo user;
bool database_ready;
</%request>
<%cpp>
{
    log_debug("%s", request.getUrl().c_str());

    // verify server is ready
    if (!database_ready) {
        log_debug ("Database is not ready yet.");
        std::string err =  TRANSLATE_ME ("Database is not ready yet, please try again after a while.");
        http_die ("internal-error", err.c_str ());
    }

    // check user permissions
    static const std::map <BiosProfile, std::string> PERMISSIONS = {
        {BiosProfile::Dashboard, "R"},
        {BiosProfile::Admin,     "R"}
    };
    CHECK_USER_PERMISSIONS_OR_DIE (PERMISSIONS);

    // Input arguments checks, arg1, arg2 are both mandatory
    std::string checked_arg1;
    std::string checked_arg2;
    {
        // sanitize params
        std::string arg1 = qparam.param ("arg1");
        if (arg1.empty () || !persist::is_ok_name (arg1.c_str ())) {
            http_die ("request-param-required", "arg1");
        }
        checked_arg1 = arg1;

        std::string arg2 = qparam.param ("arg2");
        if (arg2.empty ()) {
            http_die ("request-param-required", "arg2");
        }
        check_regex_text_or_die ("arg2", arg2, checked_arg2, "^[_,a-z]{1,1024}$");
        // sanitize params end
    }

    // arg1 is a single value OR a comma-separated list of element identifiers (DC iNames's)
    std::vector<std::string> DCs;
    {
        cxxtools::split(",", checked_arg1, std::back_inserter(DCs));
    }

    // arg2 is a single value OR a comma-separated list formed
    // from a list of permissible values (PARAM_TO_SRC)
    std::vector<std::string> requestedParams;
    {
        cxxtools::split(",", checked_arg2, std::back_inserter(requestedParams));

        // check requestedParams inputs
        for (const std::string& param: requestedParams) {
            if (!s_is_valid_param(param)) {
                std::string all_valid_params = utils::join_keys_map (PARAM_TO_SRC, ", ");
                http_die ("request-param-bad", "arg2",
                    std::string ("value '").append (param).append ("'").c_str (),
                    std::string ("one of the following values: [").append(all_valid_params).append("].").c_str ());
            }
        }
    }

    // check that DCs exists
    std::map<std::string, uint32_t> DCIDs;
    {
        auto allDcsShort = asset_mgr.get_items1("datacenter", "");
        if (allDcsShort.status == 0) {
            std::string err =  TRANSLATE_ME ("Error while retrieving information about datacenters.");
            http_die ("internal-error", err.c_str ());
        }

        for (auto const& dc_iName : DCs) {
            int64_t dbid = DBAssets::name_to_asset_id (dc_iName);
            if (dbid == -1) {
                http_die ("element-not-found", dc_iName.c_str ());
            }
            if (dbid == -2) {
                std::string err =  TRANSLATE_ME ("Connecting to database failed.");
                http_die ("internal-error", err.c_str ());
            }
            auto it = allDcsShort.item.find (uint32_t(dbid));
            if (it == allDcsShort.item.end()) {
                http_die ("element-not-found", dc_iName.c_str ());
            }

            DCIDs.emplace(dc_iName, uint32_t(dbid)); // dc_id
        }
    }

    // get datas for DCs
    std::map<std::string, std::map<std::string, std::string>> dataDc;
    for (const auto& dc_iName : DCs) {
        // get metrics related to dc
        std::map<std::string, std::string> dcMetrics;
        {
            fty::shm::shmMetrics metrics;
            if (fty::shm::read_metrics(dc_iName, ".*", metrics) != 0) {
                std::string err =  TRANSLATE_ME ("See log for more detail");
                http_die ("internal-error", err.c_str ());
            }

            for (auto &metric : metrics) {
                dcMetrics.emplace(fty_proto_type(metric), fty_proto_value(metric));
            }
        }

        dataDc.emplace(dc_iName, std::map<std::string, std::string>());

        for (const auto& param : requestedParams) {
            std::string value = "NaN"; // default (undefined)
            if (is_trend(param)) {
                double tv = s_compute_trend_value(param, dcMetrics);
                value = std::to_string(tv);
            }
            else if (dcMetrics.count(PARAM_TO_SRC.at(param)) != 0) {
                value = dcMetrics.at(PARAM_TO_SRC.at(param));
            }

            // append param/value
            dataDc.at(dc_iName).emplace(param, value);
        }
    }

    // All requestedParams values are in dataDc
    // Serialize

    std::string json = "{\"datacenter_indicators\": ["; // open the main object

    bool first = true;
    for (const auto& dc_iName : DCs) {
        auto dc_id = DCIDs.at(dc_iName);

        std::string dc_friendlyName;
        {
            std::pair<std::string,std::string> p = DBAssets::id_to_name_ext_name(dc_id);
            if (p.first != dc_iName) {
                std::string err = TRANSLATE_ME ("Database failure");
                http_die ("internal-error", err.c_str ());
            }
            dc_friendlyName = p.second;
        }

        if (!first) {
            json += ","; // objects sep
        }

        json += "{"; // open object
        json += "\"id\": \"" + dc_iName + "\",";
        json += "\"name\": \"" + dc_friendlyName + "\",";

        for (const auto& pair : dataDc.at(dc_iName)) {
            std::string param = pair.first;
            std::string value = pair.second;

            // JSON do not accept "nan", "NaN", but "null"
            if ((value == "NaN") || (value == "nan")) {
                value = "null";
            }

            json += "\"" + param + "\":" + value + ",";
        }

        json.pop_back(); // rm trailing comma
        json += "}"; // close object

        first = false;
    }

    json += "]}"; // close the main object

    reply.out() << json;
}
</%cpp>
