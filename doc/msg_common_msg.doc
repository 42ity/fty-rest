#### msg_common_msg - common messages

common_msg - common messages

Please add '@discuss' section in './../src/msg/common_msg.cc'.

This is the class interface:

```h
    //  Create a new common_msg
    common_msg_t *
        common_msg_new (int id);
    
    //  Destroy the common_msg
    void
        common_msg_destroy (common_msg_t **self_p);
    
    //  Parse a zmsg_t and decides whether it is common_msg. Returns
    //  true if it is, false otherwise. Doesn't destroy or modify the
    //  original message.
    bool
        is_common_msg (zmsg_t *msg_p);
    
    //  Parse a common_msg from zmsg_t. Returns a new object, or NULL if
    //  the message could not be parsed, or was NULL. Destroys msg and
    //  nullifies the msg reference.
    common_msg_t *
        common_msg_decode (zmsg_t **msg_p);
    
    //  Encode common_msg into zmsg and destroy it. Returns a newly created
    //  object or NULL if error. Use when not in control of sending the message.
    zmsg_t *
        common_msg_encode (common_msg_t **self_p);
    
    //  Receive and parse a common_msg from the socket. Returns new object,
    //  or NULL if error. Will block if there's no message waiting.
    common_msg_t *
        common_msg_recv (void *input);
    
    //  Receive and parse a common_msg from the socket. Returns new object,
    //  or NULL either if there was no input waiting, or the recv was interrupted.
    common_msg_t *
        common_msg_recv_nowait (void *input);
    
    //  Send the common_msg to the output, and destroy it
    int
        common_msg_send (common_msg_t **self_p, void *output);
    
    //  Send the common_msg to the output, and do not destroy it
    int
        common_msg_send_again (common_msg_t *self, void *output);
    
    //  Encode the GET_MEASURE_TYPE_I
    zmsg_t *
        common_msg_encode_get_measure_type_i (
            uint16_t mt_id);
    
    //  Encode the GET_MEASURE_TYPE_S
    zmsg_t *
        common_msg_encode_get_measure_type_s (
            const char *mt_name,
            const char *mt_unit);
    
    //  Encode the GET_MEASURE_SUBTYPE_I
    zmsg_t *
        common_msg_encode_get_measure_subtype_i (
            uint16_t mt_id,
            uint16_t mts_id);
    
    //  Encode the GET_MEASURE_SUBTYPE_S
    zmsg_t *
        common_msg_encode_get_measure_subtype_s (
            uint16_t mt_id,
            const char *mts_name,
            byte mts_scale);
    
    //  Encode the RETURN_MEASURE_TYPE
    zmsg_t *
        common_msg_encode_return_measure_type (
            uint16_t mt_id,
            const char *mt_name,
            const char *mt_unit);
    
    //  Encode the RETURN_MEASURE_SUBTYPE
    zmsg_t *
        common_msg_encode_return_measure_subtype (
            uint16_t mts_id,
            uint16_t mt_id,
            byte mts_scale,
            const char *mts_name);
    
    //  Encode the FAIL
    zmsg_t *
        common_msg_encode_fail (
            byte errtype,
            uint32_t errorno,
            const char *errmsg,
            zhash_t *aux);
    
    //  Encode the DB_OK
    zmsg_t *
        common_msg_encode_db_ok (
            uint32_t rowid,
            zhash_t *aux);
    
    //  Encode the CLIENT
    zmsg_t *
        common_msg_encode_client (
            const char *name);
    
    //  Encode the INSERT_CLIENT
    zmsg_t *
        common_msg_encode_insert_client (
            zmsg_t *msg);
    
    //  Encode the UPDATE_CLIENT
    zmsg_t *
        common_msg_encode_update_client (
            uint32_t client_id,
            zmsg_t *msg);
    
    //  Encode the DELETE_CLIENT
    zmsg_t *
        common_msg_encode_delete_client (
            uint32_t client_id);
    
    //  Encode the RETURN_CLIENT
    zmsg_t *
        common_msg_encode_return_client (
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Encode the NEW_MEASUREMENT
    zmsg_t *
        common_msg_encode_new_measurement (
            const char *client_name,
            const char *device_name,
            const char *device_type,
            uint16_t mt_id,
            uint16_t mts_id,
            uint64_t value);
    
    //  Encode the CLIENT_INFO
    zmsg_t *
        common_msg_encode_client_info (
            uint32_t client_id,
            uint32_t device_id,
            zchunk_t *info,
            uint32_t date);
    
    //  Encode the INSERT_CINFO
    zmsg_t *
        common_msg_encode_insert_cinfo (
            zmsg_t *msg);
    
    //  Encode the DELETE_CINFO
    zmsg_t *
        common_msg_encode_delete_cinfo (
            uint32_t cinfo_id);
    
    //  Encode the RETURN_CINFO
    zmsg_t *
        common_msg_encode_return_cinfo (
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Encode the DEVICE
    zmsg_t *
        common_msg_encode_device (
            uint32_t devicetype_id,
            const char *name);
    
    //  Encode the INSERT_DEVICE
    zmsg_t *
        common_msg_encode_insert_device (
            zmsg_t *msg);
    
    //  Encode the DELETE_DEVICE
    zmsg_t *
        common_msg_encode_delete_device (
            uint32_t device_id);
    
    //  Encode the RETURN_DEVICE
    zmsg_t *
        common_msg_encode_return_device (
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Encode the DEVICE_TYPE
    zmsg_t *
        common_msg_encode_device_type (
            const char *name);
    
    //  Encode the INSERT_DEVTYPE
    zmsg_t *
        common_msg_encode_insert_devtype (
            zmsg_t *msg);
    
    //  Encode the DELETE_DEVTYPE
    zmsg_t *
        common_msg_encode_delete_devtype (
            uint32_t devicetype_id);
    
    //  Encode the RETURN_DEVTYPE
    zmsg_t *
        common_msg_encode_return_devtype (
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Encode the GET_CLIENT
    zmsg_t *
        common_msg_encode_get_client (
            uint32_t client_id);
    
    //  Encode the GET_CINFO
    zmsg_t *
        common_msg_encode_get_cinfo (
            uint32_t cinfo_id);
    
    //  Encode the GET_DEVICE
    zmsg_t *
        common_msg_encode_get_device (
            uint32_t device_id);
    
    //  Encode the GET_DEVTYPE
    zmsg_t *
        common_msg_encode_get_devtype (
            uint32_t devicetype_id);
    
    //  Encode the GET_LAST_MEASUREMENTS
    zmsg_t *
        common_msg_encode_get_last_measurements (
            uint32_t device_id);
    
    //  Encode the RETURN_LAST_MEASUREMENTS
    zmsg_t *
        common_msg_encode_return_last_measurements (
            uint32_t device_id,
            const char *device_name,
            zlist_t *measurements);
    
    
    //  Send the GET_MEASURE_TYPE_I to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_measure_type_i (void *output,
            uint16_t mt_id);
    
    //  Send the GET_MEASURE_TYPE_S to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_measure_type_s (void *output,
            const char *mt_name,
            const char *mt_unit);
    
    //  Send the GET_MEASURE_SUBTYPE_I to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_measure_subtype_i (void *output,
            uint16_t mt_id,
            uint16_t mts_id);
    
    //  Send the GET_MEASURE_SUBTYPE_S to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_measure_subtype_s (void *output,
            uint16_t mt_id,
            const char *mts_name,
            byte mts_scale);
    
    //  Send the RETURN_MEASURE_TYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_measure_type (void *output,
            uint16_t mt_id,
            const char *mt_name,
            const char *mt_unit);
    
    //  Send the RETURN_MEASURE_SUBTYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_measure_subtype (void *output,
            uint16_t mts_id,
            uint16_t mt_id,
            byte mts_scale,
            const char *mts_name);
    
    //  Send the FAIL to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_fail (void *output,
            byte errtype,
            uint32_t errorno,
            const char *errmsg,
            zhash_t *aux);
    
    //  Send the DB_OK to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_db_ok (void *output,
            uint32_t rowid,
            zhash_t *aux);
    
    //  Send the CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_client (void *output,
            const char *name);
    
    //  Send the INSERT_CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_insert_client (void *output,
            zmsg_t *msg);
    
    //  Send the UPDATE_CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_update_client (void *output,
            uint32_t client_id,
            zmsg_t *msg);
    
    //  Send the DELETE_CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_delete_client (void *output,
            uint32_t client_id);
    
    //  Send the RETURN_CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_client (void *output,
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Send the NEW_MEASUREMENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_new_measurement (void *output,
            const char *client_name,
            const char *device_name,
            const char *device_type,
            uint16_t mt_id,
            uint16_t mts_id,
            uint64_t value);
    
    //  Send the CLIENT_INFO to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_client_info (void *output,
            uint32_t client_id,
            uint32_t device_id,
            zchunk_t *info,
            uint32_t date);
    
    //  Send the INSERT_CINFO to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_insert_cinfo (void *output,
            zmsg_t *msg);
    
    //  Send the DELETE_CINFO to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_delete_cinfo (void *output,
            uint32_t cinfo_id);
    
    //  Send the RETURN_CINFO to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_cinfo (void *output,
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Send the DEVICE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_device (void *output,
            uint32_t devicetype_id,
            const char *name);
    
    //  Send the INSERT_DEVICE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_insert_device (void *output,
            zmsg_t *msg);
    
    //  Send the DELETE_DEVICE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_delete_device (void *output,
            uint32_t device_id);
    
    //  Send the RETURN_DEVICE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_device (void *output,
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Send the DEVICE_TYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_device_type (void *output,
            const char *name);
    
    //  Send the INSERT_DEVTYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_insert_devtype (void *output,
            zmsg_t *msg);
    
    //  Send the DELETE_DEVTYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_delete_devtype (void *output,
            uint32_t devicetype_id);
    
    //  Send the RETURN_DEVTYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_devtype (void *output,
            uint32_t rowid,
            zmsg_t *msg);
    
    //  Send the GET_CLIENT to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_client (void *output,
            uint32_t client_id);
    
    //  Send the GET_CINFO to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_cinfo (void *output,
            uint32_t cinfo_id);
    
    //  Send the GET_DEVICE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_device (void *output,
            uint32_t device_id);
    
    //  Send the GET_DEVTYPE to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_devtype (void *output,
            uint32_t devicetype_id);
    
    //  Send the GET_LAST_MEASUREMENTS to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_get_last_measurements (void *output,
            uint32_t device_id);
    
    //  Send the RETURN_LAST_MEASUREMENTS to the output in one step
    //  WARNING, this call will fail if output is of type ZMQ_ROUTER.
    int
        common_msg_send_return_last_measurements (void *output,
            uint32_t device_id,
            const char *device_name,
            zlist_t *measurements);
    
    //  Duplicate the common_msg message
    common_msg_t *
        common_msg_dup (common_msg_t *self);
    
    //  Print contents of message to stdout
    void
        common_msg_print (common_msg_t *self);
    
    //  Get/set the message routing id
    zframe_t *
        common_msg_routing_id (common_msg_t *self);
    void
        common_msg_set_routing_id (common_msg_t *self, zframe_t *routing_id);
    
    //  Get the common_msg id and printable command
    int
        common_msg_id (common_msg_t *self);
    void
        common_msg_set_id (common_msg_t *self, int id);
    const char *
        common_msg_command (common_msg_t *self);
    
    //  Get/set the mt_id field
    uint16_t
        common_msg_mt_id (common_msg_t *self);
    void
        common_msg_set_mt_id (common_msg_t *self, uint16_t mt_id);
    
    //  Get/set the mt_name field
    const char *
        common_msg_mt_name (common_msg_t *self);
    void
        common_msg_set_mt_name (common_msg_t *self, const char *format, ...);
    
    //  Get/set the mt_unit field
    const char *
        common_msg_mt_unit (common_msg_t *self);
    void
        common_msg_set_mt_unit (common_msg_t *self, const char *format, ...);
    
    //  Get/set the mts_id field
    uint16_t
        common_msg_mts_id (common_msg_t *self);
    void
        common_msg_set_mts_id (common_msg_t *self, uint16_t mts_id);
    
    //  Get/set the mts_name field
    const char *
        common_msg_mts_name (common_msg_t *self);
    void
        common_msg_set_mts_name (common_msg_t *self, const char *format, ...);
    
    //  Get/set the mts_scale field
    byte
        common_msg_mts_scale (common_msg_t *self);
    void
        common_msg_set_mts_scale (common_msg_t *self, byte mts_scale);
    
    //  Get/set the errtype field
    byte
        common_msg_errtype (common_msg_t *self);
    void
        common_msg_set_errtype (common_msg_t *self, byte errtype);
    
    //  Get/set the errorno field
    uint32_t
        common_msg_errorno (common_msg_t *self);
    void
        common_msg_set_errorno (common_msg_t *self, uint32_t errorno);
    
    //  Get/set the errmsg field
    const char *
        common_msg_errmsg (common_msg_t *self);
    void
        common_msg_set_errmsg (common_msg_t *self, const char *format, ...);
    
    //  Get/set the aux field
    zhash_t *
        common_msg_aux (common_msg_t *self);
    //  Get the aux field and transfer ownership to caller
    zhash_t *
        common_msg_get_aux (common_msg_t *self);
    //  Set the aux field, transferring ownership from caller
    void
        common_msg_set_aux (common_msg_t *self, zhash_t **aux_p);
    
    //  Get/set a value in the aux dictionary
    const char *
        common_msg_aux_string (common_msg_t *self,
            const char *key, const char *default_value);
    uint64_t
        common_msg_aux_number (common_msg_t *self,
            const char *key, uint64_t default_value);
    void
        common_msg_aux_insert (common_msg_t *self,
            const char *key, const char *format, ...);
    size_t
        common_msg_aux_size (common_msg_t *self);
    
    //  Get/set the rowid field
    uint32_t
        common_msg_rowid (common_msg_t *self);
    void
        common_msg_set_rowid (common_msg_t *self, uint32_t rowid);
    
    //  Get/set the name field
    const char *
        common_msg_name (common_msg_t *self);
    void
        common_msg_set_name (common_msg_t *self, const char *format, ...);
    
    //  Get a copy of the msg field
    zmsg_t *
        common_msg_msg (common_msg_t *self);
    //  Get the msg field and transfer ownership to caller
    zmsg_t *
        common_msg_get_msg (common_msg_t *self);
    //  Set the msg field, transferring ownership from caller
    void
        common_msg_set_msg (common_msg_t *self, zmsg_t **msg_p);
    
    //  Get/set the client_id field
    uint32_t
        common_msg_client_id (common_msg_t *self);
    void
        common_msg_set_client_id (common_msg_t *self, uint32_t client_id);
    
    //  Get/set the client_name field
    const char *
        common_msg_client_name (common_msg_t *self);
    void
        common_msg_set_client_name (common_msg_t *self, const char *format, ...);
    
    //  Get/set the device_name field
    const char *
        common_msg_device_name (common_msg_t *self);
    void
        common_msg_set_device_name (common_msg_t *self, const char *format, ...);
    
    //  Get/set the device_type field
    const char *
        common_msg_device_type (common_msg_t *self);
    void
        common_msg_set_device_type (common_msg_t *self, const char *format, ...);
    
    //  Get/set the value field
    uint64_t
        common_msg_value (common_msg_t *self);
    void
        common_msg_set_value (common_msg_t *self, uint64_t value);
    
    //  Get/set the device_id field
    uint32_t
        common_msg_device_id (common_msg_t *self);
    void
        common_msg_set_device_id (common_msg_t *self, uint32_t device_id);
    
    //  Get a copy of the info field
    zchunk_t *
        common_msg_info (common_msg_t *self);
    //  Get the info field and transfer ownership to caller
    zchunk_t *
        common_msg_get_info (common_msg_t *self);
    //  Set the info field, transferring ownership from caller
    void
        common_msg_set_info (common_msg_t *self, zchunk_t **chunk_p);
    
    //  Get/set the date field
    uint32_t
        common_msg_date (common_msg_t *self);
    void
        common_msg_set_date (common_msg_t *self, uint32_t date);
    
    //  Get/set the cinfo_id field
    uint32_t
        common_msg_cinfo_id (common_msg_t *self);
    void
        common_msg_set_cinfo_id (common_msg_t *self, uint32_t cinfo_id);
    
    //  Get/set the devicetype_id field
    uint32_t
        common_msg_devicetype_id (common_msg_t *self);
    void
        common_msg_set_devicetype_id (common_msg_t *self, uint32_t devicetype_id);
    
    //  Get/set the measurements field
    zlist_t *
        common_msg_measurements (common_msg_t *self);
    //  Get the measurements field and transfer ownership to caller
    zlist_t *
        common_msg_get_measurements (common_msg_t *self);
    //  Set the measurements field, transferring ownership from caller
    void
        common_msg_set_measurements (common_msg_t *self, zlist_t **measurements_p);
    
    //  Iterate through the measurements field, and append a measurements value
    const char *
        common_msg_measurements_first (common_msg_t *self);
    const char *
        common_msg_measurements_next (common_msg_t *self);
    void
        common_msg_measurements_append (common_msg_t *self, const char *format, ...);
    size_t
        common_msg_measurements_size (common_msg_t *self);
    
    //  Self test of this class
    int
        common_msg_test (bool verbose);
```
Please add '@interface' section in './../src/msg/common_msg.cc'.

This is the class self test code:

```cc
    //  Simple create/destroy test
    common_msg_t *self = common_msg_new (0);
    assert (self);
    common_msg_destroy (&self);
    
    //  Create pair of sockets we can send through
    zsock_t *input = zsock_new (ZMQ_ROUTER);
    assert (input);
    zsock_connect (input, "inproc://selftest-common_msg");
    
    zsock_t *output = zsock_new (ZMQ_DEALER);
    assert (output);
    zsock_bind (output, "inproc://selftest-common_msg");
    
    //  Encode/send/decode and verify each message type
    int instance;
    common_msg_t *copy;
    self = common_msg_new (COMMON_MSG_GET_MEASURE_TYPE_I);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mt_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_mt_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_MEASURE_TYPE_S);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mt_name (self, "Life is short but Now lasts for ever");
    common_msg_set_mt_unit (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (streq (common_msg_mt_name (self), "Life is short but Now lasts for ever"));
        assert (streq (common_msg_mt_unit (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_MEASURE_SUBTYPE_I);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mt_id (self, 123);
    common_msg_set_mts_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_mt_id (self) == 123);
        assert (common_msg_mts_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_MEASURE_SUBTYPE_S);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mt_id (self, 123);
    common_msg_set_mts_name (self, "Life is short but Now lasts for ever");
    common_msg_set_mts_scale (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_mt_id (self) == 123);
        assert (streq (common_msg_mts_name (self), "Life is short but Now lasts for ever"));
        assert (common_msg_mts_scale (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_MEASURE_TYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mt_id (self, 123);
    common_msg_set_mt_name (self, "Life is short but Now lasts for ever");
    common_msg_set_mt_unit (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_mt_id (self) == 123);
        assert (streq (common_msg_mt_name (self), "Life is short but Now lasts for ever"));
        assert (streq (common_msg_mt_unit (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_MEASURE_SUBTYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_mts_id (self, 123);
    common_msg_set_mt_id (self, 123);
    common_msg_set_mts_scale (self, 123);
    common_msg_set_mts_name (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_mts_id (self) == 123);
        assert (common_msg_mt_id (self) == 123);
        assert (common_msg_mts_scale (self) == 123);
        assert (streq (common_msg_mts_name (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_FAIL);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_errtype (self, 123);
    common_msg_set_errorno (self, 123);
    common_msg_set_errmsg (self, "Life is short but Now lasts for ever");
    common_msg_aux_insert (self, "Name", "Brutus");
    common_msg_aux_insert (self, "Age", "%d", 43);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_errtype (self) == 123);
        assert (common_msg_errorno (self) == 123);
        assert (streq (common_msg_errmsg (self), "Life is short but Now lasts for ever"));
        assert (common_msg_aux_size (self) == 2);
        assert (streq (common_msg_aux_string (self, "Name", "?"), "Brutus"));
        assert (common_msg_aux_number (self, "Age", 0) == 43);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DB_OK);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_rowid (self, 123);
    common_msg_aux_insert (self, "Name", "Brutus");
    common_msg_aux_insert (self, "Age", "%d", 43);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_rowid (self) == 123);
        assert (common_msg_aux_size (self) == 2);
        assert (streq (common_msg_aux_string (self, "Name", "?"), "Brutus"));
        assert (common_msg_aux_number (self, "Age", 0) == 43);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_name (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (streq (common_msg_name (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_INSERT_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    zmsg_t *insert_client_msg = zmsg_new ();
    common_msg_set_msg (self, &insert_client_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_UPDATE_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_client_id (self, 123);
    zmsg_t *update_client_msg = zmsg_new ();
    common_msg_set_msg (self, &update_client_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_client_id (self) == 123);
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DELETE_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_client_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_client_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_rowid (self, 123);
    zmsg_t *return_client_msg = zmsg_new ();
    common_msg_set_msg (self, &return_client_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_rowid (self) == 123);
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_NEW_MEASUREMENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_client_name (self, "Life is short but Now lasts for ever");
    common_msg_set_device_name (self, "Life is short but Now lasts for ever");
    common_msg_set_device_type (self, "Life is short but Now lasts for ever");
    common_msg_set_mt_id (self, 123);
    common_msg_set_mts_id (self, 123);
    common_msg_set_value (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (streq (common_msg_client_name (self), "Life is short but Now lasts for ever"));
        assert (streq (common_msg_device_name (self), "Life is short but Now lasts for ever"));
        assert (streq (common_msg_device_type (self), "Life is short but Now lasts for ever"));
        assert (common_msg_mt_id (self) == 123);
        assert (common_msg_mts_id (self) == 123);
        assert (common_msg_value (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_CLIENT_INFO);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_client_id (self, 123);
    common_msg_set_device_id (self, 123);
    zchunk_t *client_info_info = zchunk_new ("Captcha Diem", 12);
    common_msg_set_info (self, &client_info_info);
    common_msg_set_date (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_client_id (self) == 123);
        assert (common_msg_device_id (self) == 123);
        assert (memcmp (zchunk_data (common_msg_info (self)), "Captcha Diem", 12) == 0);
        assert (common_msg_date (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_INSERT_CINFO);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    zmsg_t *insert_cinfo_msg = zmsg_new ();
    common_msg_set_msg (self, &insert_cinfo_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DELETE_CINFO);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_cinfo_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_cinfo_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_CINFO);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_rowid (self, 123);
    zmsg_t *return_cinfo_msg = zmsg_new ();
    common_msg_set_msg (self, &return_cinfo_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_rowid (self) == 123);
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DEVICE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_devicetype_id (self, 123);
    common_msg_set_name (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_devicetype_id (self) == 123);
        assert (streq (common_msg_name (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_INSERT_DEVICE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    zmsg_t *insert_device_msg = zmsg_new ();
    common_msg_set_msg (self, &insert_device_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DELETE_DEVICE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_device_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_device_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_DEVICE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_rowid (self, 123);
    zmsg_t *return_device_msg = zmsg_new ();
    common_msg_set_msg (self, &return_device_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_rowid (self) == 123);
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DEVICE_TYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_name (self, "Life is short but Now lasts for ever");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (streq (common_msg_name (self), "Life is short but Now lasts for ever"));
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_INSERT_DEVTYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    zmsg_t *insert_devtype_msg = zmsg_new ();
    common_msg_set_msg (self, &insert_devtype_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_DELETE_DEVTYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_devicetype_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_devicetype_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_DEVTYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_rowid (self, 123);
    zmsg_t *return_devtype_msg = zmsg_new ();
    common_msg_set_msg (self, &return_devtype_msg);
    zmsg_addstr (common_msg_msg (self), "Hello, World");
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_rowid (self) == 123);
        assert (zmsg_size (common_msg_msg (self)) == 1);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_CLIENT);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_client_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_client_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_CINFO);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_cinfo_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_cinfo_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_DEVICE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_device_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_device_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_DEVTYPE);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_devicetype_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_devicetype_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_GET_LAST_MEASUREMENTS);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_device_id (self, 123);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_device_id (self) == 123);
        common_msg_destroy (&self);
    }
    self = common_msg_new (COMMON_MSG_RETURN_LAST_MEASUREMENTS);
    
    //  Check that _dup works on empty message
    copy = common_msg_dup (self);
    assert (copy);
    common_msg_destroy (&copy);
    
    common_msg_set_device_id (self, 123);
    common_msg_set_device_name (self, "Life is short but Now lasts for ever");
    common_msg_measurements_append (self, "Name: %s", "Brutus");
    common_msg_measurements_append (self, "Age: %d", 43);
    //  Send twice from same object
    common_msg_send_again (self, output);
    common_msg_send (&self, output);
    
    for (instance = 0; instance < 2; instance++) {
        self = common_msg_recv (input);
        assert (self);
        assert (common_msg_routing_id (self));
    
        assert (common_msg_device_id (self) == 123);
        assert (streq (common_msg_device_name (self), "Life is short but Now lasts for ever"));
        assert (common_msg_measurements_size (self) == 2);
        assert (streq (common_msg_measurements_first (self), "Name: Brutus"));
        assert (streq (common_msg_measurements_next (self), "Age: 43"));
        common_msg_destroy (&self);
    }
    
    zsock_destroy (&input);
    zsock_destroy (&output);
```

